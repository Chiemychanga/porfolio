<p><img src="/assets/img/work/proj-3/thumb.jpg" alt="Operator Overloading" /></p>

<p>This was a C++ program that is simulating a game of players that have weapons, powers, and locations. The user is able to use operator overloading to add and remove things based on their desires.</p>

<p><img src="/assets/img/work/proj-3/img1.png" alt="Operator Overloading" /></p>

<p>The BST of LLL’s performed excellently for the assignment, since I had a small amount of data. I was able to finish this program thank you to Karla’s requirements being less de
A different data structure would work better only if the video game had a bigger amount of data, but for a video game application where only a small amount of characters existe
Using a binary search tree to hold character’s was efficiently simple to design and the big O(log(n)) on average for insertion (reading in from external file) and search (when
Using a LLL was very efficient for adding, since I did it unsorted and just added at the head of the list everytime. Searching is worst case O(n) if it was at the end of the li
If I had more time and only if I had over a high amount of data, then I would create a balanced tree, such as an AVL or 2-3-4 or a red-black tree, with the same tree inside for
All of my classes had clear responsibilities. I cut out many classes to make my code less bulky and separated. That’s why I didn’t have a class BST managing a BST node, which h</p>

<p>I used gdb to debug my seg faults and other problems. I find gdb very useful when I ran into a couple of problems:
Some of my characters had the same weapons, which was very odd and difficult to find until I used gdb. Gdb showed me that each of my characters had the correct weapons and powe
At another point, I also figured out why I couldn’t find certain data in my data structures, and I used gdb to look at where my code was supposed to go by using breakpoints, la</p>

